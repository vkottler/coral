/**
 * \file
 * \brief Generated by ifgen (3.3.1).
 */

#include "generated/structs/BufferState.h"

namespace Coral
{

/* Span method defined in header. */

std::size_t BufferState::encode_swapped(Buffer *buffer) const
{
    std::size_t idx = 0;
    auto buf = buffer->data();

    /* uint32_t write_cursor */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(write_cursor);
    idx += 4;

    /* uint32_t read_cursor */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(read_cursor);
    idx += 4;

    /* uint32_t read_count */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(read_count);
    idx += 4;

    /* uint32_t write_count */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(write_count);
    idx += 4;

    return idx;
}

/* 'BufferState::encode' defined in header. */

std::size_t BufferState::decode_swapped(const Buffer *buffer)
{
    std::size_t idx = 0;
    auto buf = buffer->data();

    /* uint32_t write_cursor */
    write_cursor =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t read_cursor */
    read_cursor =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t read_count */
    read_count = std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t write_count */
    write_count =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    return idx;
}

/* 'BufferState::decode' defined in header. */

/* Stream interfaces. */
byte_istream &operator>>(byte_istream &stream, BufferState &instance)
{
    stream.read(instance.raw()->data(), BufferState::size);
    return stream;
}

byte_ostream &operator<<(byte_ostream &stream, const BufferState &instance)
{
    stream.write(instance.raw_ro()->data(), BufferState::size);
    return stream;
}

}; // namespace Coral
