/**
 * \file
 * \brief Generated by ifgen (2.0.2).
 */

#include "generated/structs/BufferState.h"

namespace Coral
{

BufferState::Buffer *BufferState::raw()
{
    return reinterpret_cast<Buffer *>(this);
}

BufferState::Span BufferState::span()
{
    return Span(*raw());
}

const BufferState::Buffer *BufferState::raw_ro() const
{
    return reinterpret_cast<const Buffer *>(this);
}

std::size_t BufferState::encode_swapped(Buffer *buffer) const
{
    std::size_t idx = 0;
    auto buf = buffer->data();

    /* uint32_t write_cursor */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(write_cursor);
    idx += 4;

    /* uint32_t read_cursor */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(read_cursor);
    idx += 4;

    /* uint32_t read_count */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(read_count);
    idx += 4;

    /* uint32_t write_count */
    *reinterpret_cast<uint32_t *>(&buf[idx]) = std::byteswap(write_count);
    idx += 4;

    return idx;
}

std::size_t BufferState::encode(Buffer *buffer, std::endian endianness) const
{
    std::size_t result = size;

    if (endianness == std::endian::native)
    {
        *buffer = *raw_ro();
    }
    else
    {
        result = BufferState::encode_swapped(buffer);
    }

    return result;
}

const BufferState &BufferState::swap()
{
    encode_swapped(raw());
    return *this;
}

std::size_t BufferState::decode_swapped(const Buffer *buffer)
{
    std::size_t idx = 0;
    auto buf = buffer->data();

    /* uint32_t write_cursor */
    write_cursor =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t read_cursor */
    read_cursor =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t read_count */
    read_count = std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    /* uint32_t write_count */
    write_count =
        std::byteswap(*reinterpret_cast<const uint32_t *>(&buf[idx]));
    idx += 4;

    return idx;
}

std::size_t BufferState::decode(const Buffer *buffer, std::endian endianness)
{
    std::size_t result = size;

    if (endianness == std::endian::native)
    {
        auto buf = raw();
        *buf = *buffer;
    }
    else
    {
        result = BufferState::decode_swapped(buffer);
    }

    return result;
}

/* Stream interfaces. */
byte_istream &operator>>(byte_istream &stream, BufferState &instance)
{
    stream.read(instance.raw()->data(), BufferState::size);
    return stream;
}

byte_ostream &operator<<(byte_ostream &stream, const BufferState &instance)
{
    stream.write(instance.raw_ro()->data(), BufferState::size);
    return stream;
}

}; // namespace Coral
