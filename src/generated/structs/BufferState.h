/**
 * \file
 * \brief Generated by ifgen (2.0.2).
 * {
 *   "fields": [
 *     {
 *       "name": "write_cursor",
 *       "type": "uint32_t"
 *     },
 *     {
 *       "name": "read_cursor",
 *       "type": "uint32_t"
 *     },
 *     {
 *       "name": "read_count",
 *       "type": "uint32_t"
 *     },
 *     {
 *       "name": "write_count",
 *       "type": "uint32_t"
 *     }
 *   ],
 *   "namespace": [],
 *   "json_indent": null
 * }
 */
#pragma once

#include "../ifgen/common.h"

namespace Coral
{

struct [[gnu::packed]] BufferState
{
    /* Constant attributes. */
    static constexpr uint8_t id = 1; /*!< BufferState's identifier. */
    static constexpr std::size_t size =
        16; /*!< BufferState's size in bytes. */

    /* Fields. */
    uint32_t write_cursor;
    uint32_t read_cursor;
    uint32_t read_count;
    uint32_t write_count;

    /* Methods. */
    using Buffer = byte_array<size>;
    using Span = byte_span<size>;

    auto operator<=>(const BufferState &) const = default;

    /**
     * Get this instance as a fixed-size byte array.
     */
    Buffer *raw();

    /**
     * Get this instance as a byte span.
     */
    Span span();

    /**
     * Get this instance as a read-only fixed-size byte array.
     */
    const Buffer *raw_ro() const;

    /**
     * Encode using byte-order swapped from native.
     *
     * \param[out] buffer Buffer to write.
     * \return            The number of bytes encoded.
     */
    std::size_t encode_swapped(Buffer *buffer) const;

    /**
     * Encode this instance to a buffer.
     *
     * \param[out] buffer     Buffer to write.
     * \param[in]  endianness Byte order for encoding elements.
     * \return                The number of bytes encoded.
     */
    std::size_t encode(Buffer *buffer,
                       std::endian endianness = std::endian::native) const;

    /**
     * Swap this instance's bytes in place.
     *
     * \return A reference to the instance.
     */
    const BufferState &swap();

    /**
     * Decode using byte-order swapped from native.
     *
     * \param[in] buffer Buffer to read.
     * \return           The number of bytes decoded.
     */
    std::size_t decode_swapped(const Buffer *buffer);

    /**
     * Update this instance from a buffer.
     *
     * \param[in] buffer     Buffer to read.
     * \param[in] endianness Byte order from decoding elements.
     * \return               The number of bytes decoded.
     */
    std::size_t decode(const Buffer *buffer,
                       std::endian endianness = std::endian::native);

    /**
     * Get a JSON C string describing BufferState.
     *
     * \return A C string with JSON data contents.
     */
    static const char *json()
    {
        return "{\"build\":[{\"kind\":\"uint32\",\"name\":\"write"
               "_cursor\"},{\"kind\":\"uint32\",\"name\":\"read_"
               "cursor\"},{\"kind\":\"uint32\",\"name\":\"read_c"
               "ount\"},{\"kind\":\"uint32\",\"name\":\"write_co"
               "unt\"}],\"enums\":{\"ByteOrder\":{\"id\":2,\"ite"
               "ms\":{\"big_endian\":3,\"little_endian\":2,\"n"
               "ative\":1,\"network\":4},\"primitive\":\"uint8"
               "\",\"type\":\"int\"},\"runtimepy::ByteOrder\":{"
               "\"id\":1,\"items\":{\"big_endian\":3,\"little_e"
               "ndian\":2,\"native\":1,\"network\":4},\"primit"
               "ive\":\"uint8\",\"type\":\"int\"}},\"fields\":{\"i"
               "tems\":[]},\"meta\":{\"byte_order\":\"network\""
               ",\"id\":1},\"names\":{\"read_count\":3,\"read_c"
               "ursor\":2,\"write_count\":4,\"write_cursor\":"
               "1},\"values\":{\"read_count\":0,\"read_cursor"
               "\":0,\"write_count\":0,\"write_cursor\":0}}";
    }
};

static_assert(sizeof(BufferState) == BufferState::size);

/* Stream interfaces. */
byte_istream &operator>>(byte_istream &stream, BufferState &instance);
byte_ostream &operator<<(byte_ostream &stream, const BufferState &instance);

}; // namespace Coral
