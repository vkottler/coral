/**
 * \file
 * \brief Generated by ifgen (3.3.1).
 */

#pragma once

#include "../ifgen/common.h"

namespace Coral
{

struct [[gnu::packed]] BufferState
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1; /*!< BufferState's identifier. */
    static constexpr std::size_t size =
        16; /*!< BufferState's size in bytes. */

    /* Fields. */
    uint32_t write_cursor;
    uint32_t read_cursor;
    uint32_t read_count;
    uint32_t write_count;

    /* Methods. */
    using Buffer = byte_array<size>;
    using Span = byte_span<size>;

    auto operator<=>(const BufferState &) const = default;

    /**
     * Get this instance as a fixed-size byte array.
     */
    inline Buffer *raw()
    {
        return reinterpret_cast<Buffer *>(this);
    }

    /**
     * Get this instance as a byte span.
     */
    inline Span span()
    {
        return Span(*raw());
    }

    /**
     * Get this instance as a read-only fixed-size byte array.
     */
    inline const Buffer *raw_ro() const
    {
        return reinterpret_cast<const Buffer *>(this);
    }

    /**
     * Encode using byte-order swapped from native.
     *
     * \param[out] buffer Buffer to write.
     * \return            The number of bytes encoded.
     */
    std::size_t encode_swapped(Buffer *buffer) const;

    /**
     * Encode this instance to a buffer.
     *
     * \param[out] buffer     Buffer to write.
     * \param[in]  endianness Byte order for encoding elements.
     * \return                The number of bytes encoded.
     */
    inline std::size_t encode(
        Buffer *buffer, std::endian endianness = std::endian::native) const
    {
        std::size_t result = size;

        if (endianness == std::endian::native)
        {
            *buffer = *raw_ro();
        }
        else
        {
            result = encode_swapped(buffer);
        }

        return result;
    }

    /**
     * Swap this instance's bytes in place.
     *
     * \return A reference to the instance.
     */
    inline const BufferState &swap()
    {
        encode_swapped(raw());
        return *this;
    }

    /**
     * Decode using byte-order swapped from native.
     *
     * \param[in] buffer Buffer to read.
     * \return           The number of bytes decoded.
     */
    std::size_t decode_swapped(const Buffer *buffer);

    /**
     * Update this instance from a buffer.
     *
     * \param[in] buffer     Buffer to read.
     * \param[in] endianness Byte order from decoding elements.
     * \return               The number of bytes decoded.
     */
    inline std::size_t decode(const Buffer *buffer,
                              std::endian endianness = std::endian::native)
    {
        std::size_t result = size;

        if (endianness == std::endian::native)
        {
            auto buf = raw();
            *buf = *buffer;
        }
        else
        {
            result = decode_swapped(buffer);
        }

        return result;
    }
};

static_assert(sizeof(BufferState) == BufferState::size);

/* Stream interfaces. */
byte_istream &operator>>(byte_istream &stream, BufferState &instance);
byte_ostream &operator<<(byte_ostream &stream, const BufferState &instance);

}; // namespace Coral
